# ==========================================================
# MPC CONTROLLER (HIGHWAY + LEFT TURN + PARKING, Linearized + Safe Turn Activation)
# ==========================================================
from dynamic_env import SimpleCarEnv
import numpy as np
import time
import pybullet as p


# ==========================================================
# MPC CONTROLLER (HIGHWAY + LEFT TURN + PARKING, Linearized + Safe Turn Activation)
# ==========================================================
def mpc_control(state, obstacle_positions, dt, parking_params):
    x, y, yaw = state


    # =============================
    # VEHICLE PARAMETERS
    # =============================
    L = 2.5       # car wheelbase
    L_t = 3.0     # trailer distance
    horizon = 50


    # =============================
    # ROAD GEOMETRY
    # =============================
    lane_width = 3.5
    lane_centers = [-lane_width / 2, lane_width / 2]


    LEFT_TURN_X_START = 85.0
    LEFT_TURN_X_END = 95.0
    SIDE_ROAD_LANE_Y = 8.0
    TURN_YAW = -np.pi / 2
    SIDE_ROAD_Y_MIN = SIDE_ROAD_LANE_Y - 1.75
    SIDE_ROAD_Y_MAX = SIDE_ROAD_LANE_Y + 1.75




    # =============================
    # TURN COMMITMENT LATCH
    # =============================
    if not hasattr(mpc_control, "turn_committed"):
        mpc_control.turn_committed = False


    # =============================
    # TURN COMMITMENT LATCH WITH YAW ALIGNMENT
    # =============================
    if not hasattr(mpc_control, "turn_committed"):
        mpc_control.turn_committed = False


    # Compute yaw error
    yaw_error = TURN_YAW - yaw
    yaw_error = (yaw_error + np.pi) % (2 * np.pi) - np.pi  # normalize to [-pi, pi]


    # Activate turn only if x >= LEFT_TURN_X_START AND yaw roughly aligned
    if x >= LEFT_TURN_X_START and abs(yaw_error) < np.radians(5):
        mpc_control.turn_committed = True


    TURN_ACTIVE = mpc_control.turn_committed


    # Slow down slightly before turn for stability
    if x >= LEFT_TURN_X_START - 2.0 and not TURN_ACTIVE:
        target_speed = min(target_speed, 1.5)




    if abs(x - LEFT_TURN_X_START) < 0.5:
        print("DEBUG TURN ENTRY")
        print(f"x = {x:.2f}, y = {y:.2f}")
        print(f"current yaw = {yaw:.3f} rad ({np.degrees(yaw):.1f} deg)")
        print(f"TURN_YAW = {TURN_YAW:.3f} rad ({np.degrees(TURN_YAW):.1f} deg)")
        print(f"yaw_error = {np.degrees(yaw_error):.2f} deg")


    # =============================
    # CURRENT LANE (HIGHWAY)
    # =============================
    current_lane = min(lane_centers, key=lambda ly: abs(y - ly))
    target_lane = current_lane


    # =============================
    # OBSTACLE LOOKAHEAD
    # =============================
    LOOKAHEAD_DIST = 10.0
    min_dist = np.inf
    for ox, oy in obstacle_positions:
        if abs(oy - current_lane) < 0.7 and ox > x:
            min_dist = min(min_dist, ox - x)
    if min_dist < LOOKAHEAD_DIST:
        target_lane = lane_centers[0] if current_lane == lane_centers[1] else lane_centers[1]


    # =============================
    # SPEED PROFILE
    # =============================
    target_speed = 3.0
    if min_dist < 3.0:
        target_speed = 0.8
    elif min_dist < 5.0:
        target_speed = 1.2


    # =============================
    # PARKING PARAMETERS
    # =============================
    PARK_X, PARK_Y, PARK_YAW, PARK_X_TOL, PARK_Y_TOL, PARK_YAW_TOL = parking_params


    # =============================
    # PARKING MODE ACTIVATION
    # =============================
    dist_to_parking = np.hypot(x - PARK_X, y - PARK_Y)
    PARK_ACTIVE = TURN_ACTIVE and dist_to_parking < 15.0
    if PARK_ACTIVE:
        target_speed = np.clip(0.5 * dist_to_parking, 0.0, 1.0)


    # =============================
    # MPC SEARCH
    # =============================
    steer_candidates = np.linspace(-0.35, 0.35, 25)
    best_cost = np.inf
    best_steer = 0.0




    for steer in steer_candidates:
        # -----------------------------
        # Initialize linearized state
        # -----------------------------
        px, py, pyaw = x, y, yaw
        yaw_trailer = yaw
        py_trailer = py - L_t * (yaw_trailer - yaw)  # small-angle linear approx


        cost = 0.0


        for step in range(horizon):
            # -----------------------------
            # Linearized propagation (LaSalle model)
            # -----------------------------
            d_yaw_trailer = (target_speed / L_t) * (pyaw - yaw_trailer) * dt


            # Car linearized kinematics
            px += target_speed * np.cos(pyaw) * dt
            py += target_speed * np.sin(pyaw) * dt
            pyaw += (target_speed / L) * steer * dt  # linearized tan(steer) ≈ steer


            # Trailer linearized kinematics
            yaw_trailer += d_yaw_trailer
            py_trailer = py - L_t * (yaw_trailer - pyaw)


            # =============================
            # COST FUNCTION
            # =============================
            # -------- PARKING MODE --------
            if PARK_ACTIVE:
                cost += 30.0 * (px - PARK_X) ** 2
                cost += 40.0 * (py - PARK_Y) ** 2
                cost += 25.0 * (pyaw - PARK_YAW) ** 2
                cost += 100.0 * (yaw_trailer - PARK_YAW) ** 2
                cost += 2.0 * steer ** 2


                if step == horizon - 1:
                    if abs(px - PARK_X) > PARK_X_TOL:
                        cost += 1000.0
                    if abs(py - PARK_Y) > PARK_Y_TOL:
                        cost += 1000.0
                    if abs(pyaw - PARK_YAW) > PARK_YAW_TOL:
                        cost += 800.0


            # -------- LEFT TURN MODE --------
            elif TURN_ACTIVE:
                # Smooth yaw transition toward side road
                distance_into_side_road = px - LEFT_TURN_X_START
                transition_length = 10.0
                yaw_ref = TURN_YAW
                if distance_into_side_road > 2.0:
                    ratio = min(distance_into_side_road / transition_length, 1.0)
                    yaw_ref = TURN_YAW * (1 - ratio) + PARK_YAW * ratio


                cost += 25.0 * (py - SIDE_ROAD_LANE_Y) ** 2
                cost += 50.0 * (py_trailer - SIDE_ROAD_LANE_Y) ** 2
                cost += 80.0 * (pyaw - yaw_ref) ** 2
                cost += 0.3 * steer ** 2
                if step == horizon - 1:
                    cost += 500.0 * (pyaw - TURN_YAW) ** 2




            # -------- HIGHWAY MODE --------
            else:
                lane_error = target_lane - py
                yaw_ref = np.clip(0.6 * lane_error, -0.3, 0.3)
                cost += 20.0 * (py - target_lane) ** 2
                cost += 40.0 * (py_trailer - target_lane) ** 2
                cost += 8.0 * (pyaw - yaw_ref) ** 2
                cost += 2.0 * steer ** 2


                # ---- road boundary penalty to prevent green area wander ----
                road_bound = 2.5 * lane_width
                if abs(py) > road_bound:
                    cost += 500.0
                if abs(py_trailer) > road_bound:
                    cost += 500.0
        # =============================
        # HARD COMMITMENT TO SIDE ROAD
        # =============================
        if px > LEFT_TURN_X_START:
            if py < SIDE_ROAD_Y_MIN or py > SIDE_ROAD_Y_MAX:
                cost += 3000.0
            if py_trailer < SIDE_ROAD_Y_MIN or py_trailer > SIDE_ROAD_Y_MAX:
                cost += 3000.0


        if cost < best_cost:
            best_cost = cost
            best_steer = steer
        if TURN_ACTIVE:
            target_speed = min(target_speed, 1.5)




    return np.array([target_speed, best_steer], dtype=np.float32), PARK_ACTIVE




# ==========================================================
# MAIN LOOP
# ==========================================================
def main():
    env = SimpleCarEnv(gui=True)
    obs, _ = env.reset()
    car_id = env.car_id


    # ======================================================
    # PHYSICS INITIALIZATION
    # ======================================================
    for j in range(p.getNumJoints(car_id)):
        name = p.getJointInfo(car_id, j)[1].decode()
        p.changeDynamics(car_id, j, lateralFriction=2.0, rollingFriction=0.02, spinningFriction=0.02)
        if "trailer_wheel" in name or "trailer_hinge" in name:
            p.setJointMotorControl2(car_id, j, p.VELOCITY_CONTROL, targetVelocity=0, force=0)


    print("✅ Physics initialized")


    # ======================================================
    # PARKING PARAMETERS
    # ======================================================
    PARK_X = env.side_road_x
    road_width = env.num_lanes * env.lane_width
    PARK_Y = road_width / 2 + env.side_road_length + 5.0
    PARK_YAW = -np.pi / 2
    PARK_X_TOL = 2.25
    PARK_Y_TOL = 5.0
    PARK_YAW_TOL = np.deg2rad(8.0)
    parking_params = (PARK_X, PARK_Y, PARK_YAW, PARK_X_TOL, PARK_Y_TOL, PARK_YAW_TOL)


    try:
        for step in range(2000):
            obstacle_positions = []
            for obs_id in env.obstacle_ids:
                pos, _ = p.getBasePositionAndOrientation(obs_id)
                obstacle_positions.append((pos[0], pos[1]))


            # =============================
            # Compute action using MPC
            # =============================
            action, PARK_ACTIVE = mpc_control(obs, obstacle_positions, env.dt, parking_params)
            obs, reward, terminated, truncated, _ = env.step(action)


            if step % 25 == 0:
                print(f"step {step}, obs={obs}, action={action}")


            # =============================
            # Update camera to follow car
            # =============================
            car_pos, _ = p.getBasePositionAndOrientation(car_id)
            p.resetDebugVisualizerCamera(cameraDistance=8.0, cameraYaw=270.0,
                                         cameraPitch=-20.0, cameraTargetPosition=car_pos)


            # =============================
            # Check parking success
            # =============================
            if PARK_ACTIVE:
                parking_success = (
                    abs(obs[0] - PARK_X) < PARK_X_TOL and
                    abs(obs[1] - PARK_Y) < PARK_Y_TOL and
                    abs(obs[2] - PARK_YAW) < PARK_YAW_TOL
                )
                if parking_success:
                    print("✅ Parking successful!")
                    terminated = True


            time.sleep(env.dt)
            if terminated or truncated:
                print("Episode ended")
                break


    finally:
        env.close()




if __name__ == "__main__":
    main()


Test

# ==========================================================
# MPC CONTROLLER (HIGHWAY + LEFT TURN + PARKING, Linearized + Soft Turn)
# ==========================================================


from dynamic_env import SimpleCarEnv
import numpy as np
import time
import pybullet as p


# ============================
# MPC CONTROLLER
# ============================
def mpc_control(state, obstacle_positions, dt, parking_params):
    """
    Three-mode MPC: highway, turn, and parking
    Mode switching:
        - Turn mode: activated when vehicle is close to left lane entry
        - Parking mode: activated after turn is complete and vehicle near parking target
        - Highway mode: default
    """
    x, y, yaw = state


    # -----------------------------
    # VEHICLE PARAMETERS
    # -----------------------------
    L = 2.5       # car wheelbase
    L_t = 3.0     # trailer distance
    horizon = 50


    # -----------------------------
    # ROAD GEOMETRY
    # -----------------------------
    lane_width = 3.5
    lane_centers = [-lane_width / 2, lane_width / 2]


    LEFT_TURN_X_START = 85.0
    LEFT_TURN_X_END = 95.0
    SIDE_ROAD_LANE_Y = 8.0
    TURN_YAW = -np.pi / 2
    SIDE_ROAD_Y_MIN = SIDE_ROAD_LANE_Y - 1.75
    SIDE_ROAD_Y_MAX = SIDE_ROAD_LANE_Y + 1.75


    # -----------------------------
    # PARKING PARAMETERS
    # -----------------------------
    PARK_X, PARK_Y, PARK_YAW, PARK_X_TOL, PARK_Y_TOL, PARK_YAW_TOL = parking_params
    dist_to_parking = np.hypot(x - PARK_X, y - PARK_Y)


    # -----------------------------
    # DETECT MODES
    # -----------------------------
    # Initialize mode latches
    if not hasattr(mpc_control, "turn_committed"):
        mpc_control.turn_committed = False
    if not hasattr(mpc_control, "parking_committed"):
        mpc_control.parking_committed = False


    # Highway mode is default
    mode = "highway"


    # Turn mode activation: close to turn entry and near highway lane
    if not mpc_control.turn_committed:
        # Check proximity to lane and X
        if x >= LEFT_TURN_X_START - 1.0 and y >= lane_centers[0] - 0.5 and y <= lane_centers[1] + 0.5:
            mpc_control.turn_committed = True


    if mpc_control.turn_committed and not mpc_control.parking_committed:
        # Turn is active until sufficiently completed
        if x < LEFT_TURN_X_END:
            mode = "turn"
        else:
            mpc_control.parking_committed = True


    # Parking mode activation
    if mpc_control.parking_committed:
        if dist_to_parking < 15.0:
            mode = "parking"


    # -----------------------------
    # OBSTACLE LOOKAHEAD (highway only)
    # -----------------------------
    current_lane = min(lane_centers, key=lambda ly: abs(y - ly))
    target_lane = current_lane
    min_dist = np.inf
    for ox, oy in obstacle_positions:
        if abs(oy - current_lane) < 0.7 and ox > x:
            min_dist = min(min_dist, ox - x)
    if min_dist < 10.0:
        target_lane = lane_centers[0] if current_lane == lane_centers[1] else lane_centers[1]


    # -----------------------------
    # SPEED PROFILE
    # -----------------------------
    target_speed = 3.0
    if min_dist < 3.0:
        target_speed = 0.8
    elif min_dist < 5.0:
        target_speed = 1.2


    # Slow down before turn for stability
    if mode == "turn":
        target_speed = min(target_speed, 1.5)
    elif mode == "parking":
        target_speed = np.clip(0.5 * dist_to_parking, 0.0, 1.0)


    # -----------------------------
    # MPC SEARCH
    # -----------------------------
    steer_candidates = np.linspace(-0.35, 0.35, 25)
    best_cost = np.inf
    best_steer = 0.0


    for steer in steer_candidates:
        px, py, pyaw = x, y, yaw
        yaw_trailer = yaw
        py_trailer = py - L_t * (yaw_trailer - yaw)


        cost = 0.0
        for step in range(horizon):
            # Linearized propagation
            d_yaw_trailer = (target_speed / L_t) * (pyaw - yaw_trailer) * dt
            px += target_speed * np.cos(pyaw) * dt
            py += target_speed * np.sin(pyaw) * dt
            pyaw += (target_speed / L) * steer * dt
            yaw_trailer += d_yaw_trailer
            py_trailer = py - L_t * (yaw_trailer - pyaw)


            # -----------------------------
            # COST FUNCTION PER MODE
            # -----------------------------
            if mode == "highway":
                lane_error = target_lane - py
                yaw_ref = np.clip(0.6 * lane_error, -0.3, 0.3)
                cost += 20.0 * (py - target_lane) ** 2
                cost += 40.0 * (py_trailer - target_lane) ** 2
                cost += 8.0 * (pyaw - yaw_ref) ** 2
                cost += 2.0 * steer ** 2


            elif mode == "turn":
                distance_into_side_road = px - LEFT_TURN_X_START
                transition_length = LEFT_TURN_X_END - LEFT_TURN_X_START
                yaw_ref = TURN_YAW * min(distance_into_side_road / transition_length, 1.0)
                cost += 200.0 * (py - SIDE_ROAD_LANE_Y) ** 2
                cost += 400.0 * (py_trailer - SIDE_ROAD_LANE_Y) ** 2
                cost += 150.0 * (pyaw - yaw_ref) ** 2
                cost += 5.0 * steer ** 2
                if py < SIDE_ROAD_Y_MIN or py > SIDE_ROAD_Y_MAX:
                    cost += 5000.0
                if py_trailer < SIDE_ROAD_Y_MIN or py_trailer > SIDE_ROAD_Y_MAX:
                    cost += 5000.0


            elif mode == "parking":
                cost += 30.0 * (px - PARK_X) ** 2
                cost += 40.0 * (py - PARK_Y) ** 2
                cost += 25.0 * (pyaw - PARK_YAW) ** 2
                cost += 100.0 * (yaw_trailer - PARK_YAW) ** 2
                cost += 2.0 * steer ** 2
                if step == horizon - 1:
                    if abs(px - PARK_X) > PARK_X_TOL: cost += 1000.0
                    if abs(py - PARK_Y) > PARK_Y_TOL: cost += 1000.0
                    if abs(pyaw - PARK_YAW) > PARK_YAW_TOL: cost += 800.0


        if cost < best_cost:
            best_cost = cost
            best_steer = steer


    return np.array([target_speed, best_steer], dtype=np.float32), mode == "parking"


# ==========================================================
# MAIN LOOP
# ==========================================================
def main():
    env = SimpleCarEnv(gui=True)
    obs, _ = env.reset()
    car_id = env.car_id


    # PHYSICS INITIALIZATION
    for j in range(p.getNumJoints(car_id)):
        name = p.getJointInfo(car_id, j)[1].decode()
        p.changeDynamics(car_id, j, lateralFriction=2.0, rollingFriction=0.02, spinningFriction=0.02)
        if "trailer_wheel" in name or "trailer_hinge" in name:
            p.setJointMotorControl2(car_id, j, p.VELOCITY_CONTROL, targetVelocity=0, force=0)


    print("✅ Physics initialized")


    # PARKING PARAMETERS
    PARK_X = env.side_road_x
    road_width = env.num_lanes * env.lane_width
    PARK_Y = road_width / 2 + env.side_road_length + 5.0
    PARK_YAW = -np.pi / 2
    PARK_X_TOL = 2.25
    PARK_Y_TOL = 5.0
    PARK_YAW_TOL = np.deg2rad(8.0)
    parking_params = (PARK_X, PARK_Y, PARK_YAW, PARK_X_TOL, PARK_Y_TOL, PARK_YAW_TOL)


    try:
        for step in range(2000):
            obstacle_positions = []
            for obs_id in env.obstacle_ids:
                pos, _ = p.getBasePositionAndOrientation(obs_id)
                obstacle_positions.append((pos[0], pos[1]))


            # Compute action using MPC
            action, PARK_ACTIVE = mpc_control(obs, obstacle_positions, env.dt, parking_params)
            obs, reward, terminated, truncated, _ = env.step(action)


            if step % 25 == 0:
                print(f"step {step}, obs={obs}, action={action}")


            # Update camera
            car_pos, _ = p.getBasePositionAndOrientation(car_id)
            p.resetDebugVisualizerCamera(cameraDistance=8.0, cameraYaw=270.0,
                                         cameraPitch=-20.0, cameraTargetPosition=car_pos)


            # Check parking success
            if PARK_ACTIVE:
                parking_success = (
                    abs(obs[0] - PARK_X) < PARK_X_TOL and
                    abs(obs[1] - PARK_Y) < PARK_Y_TOL and
                    abs(obs[2] - PARK_YAW) < PARK_YAW_TOL
                )
                if parking_success:
                    print("✅ Parking successful!")
                    terminated = True


            time.sleep(env.dt)
            if terminated or truncated:
                print("Episode ended")
                break


    finally:
        env.close()




if __name__ == "__main__":
    main()


